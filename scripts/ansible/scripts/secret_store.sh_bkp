#!/bin/bash
# interactive_secret_store.sh
# Interactive script to collect secrets and store them in cloud Secret Manager

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Configuration
OUTPUT_FILE="attestor_secret.json"
TEMP_FILE=$(mktemp)

# Cleanup function
cleanup() {
    rm -f "$TEMP_FILE"
    # Optionally remove the secret JSON file after storing
    # rm -f "$OUTPUT_FILE"
}
trap cleanup EXIT

# Print header
print_header() {
    echo -e "${CYAN}${BOLD}========================================${NC}"
    echo -e "${CYAN}${BOLD}  Verulink Attestor Secret Storage${NC}"
    echo -e "${CYAN}${BOLD}========================================${NC}"
    echo ""
}

# Print section header
print_section() {
    echo -e "\n${BLUE}${BOLD}>>> $1${NC}\n"
}

# Read masked input (shows xx for each character)
read_masked() {
    local prompt="$1"
    local var_name="$2"
    local value=""
    local char=""
    
    echo -n -e "${YELLOW}$prompt${NC} "
    
    # Save current terminal settings
    if [[ -t 0 ]]; then
        local old_stty=$(stty -g 2>/dev/null)
        # Disable echo and set to raw mode for immediate character reading
        stty -echo raw 2>/dev/null || stty -echo -icanon 2>/dev/null
    fi
    
    # Read character by character
    while true; do
        # Read one character (non-blocking with timeout)
        if [[ -t 0 ]]; then
            char=$(dd bs=1 count=1 2>/dev/null)
        else
            IFS= read -rsn1 char 2>/dev/null || break
        fi
        
        # Handle empty input (Enter key - newline or carriage return)
        if [[ -z "$char" ]] || [[ "$char" == $'\n' ]] || [[ "$char" == $'\r' ]]; then
            echo ""  # New line
            break
        fi
        
        # Handle backspace/delete (ASCII 127, 8, or DEL)
        if [[ "$char" == $'\177' ]] || [[ "$char" == $'\b' ]] || [[ "$char" == $'\x7f' ]]; then
            if [[ ${#value} -gt 0 ]]; then
                # Remove last character from value
                value="${value%?}"
                # Move cursor back and erase the two x's
                echo -ne "\b\b  \b\b"
            fi
            continue
        fi
        
        # Handle Ctrl+C
        if [[ "$char" == $'\x03' ]]; then
            if [[ -t 0 ]]; then
                stty "$old_stty" 2>/dev/null
            fi
            echo ""
            exit 1
        fi
        
        # Handle Ctrl+D (EOF)
        if [[ "$char" == $'\x04' ]]; then
            if [[ -t 0 ]]; then
                stty "$old_stty" 2>/dev/null
            fi
            echo ""
            break
        fi
        
        # Get character code to filter control characters
        local code
        if command -v od &> /dev/null; then
            code=$(echo -n "$char" | od -An -tu1 | tr -d ' ')
        else
            code=$(printf '%d' "'$char" 2>/dev/null)
        fi
        
        # Skip control characters (except tab)
        if [[ -n "$code" ]] && [[ "$code" -lt 32 ]] && [[ "$code" != "9" ]]; then
            continue
        fi
        
        # Add character to value and display xx
        value+="$char"
        echo -n "xx"
    done
    
    # Restore terminal settings
    if [[ -t 0 ]]; then
        stty "$old_stty" 2>/dev/null || stty echo sane 2>/dev/null
    fi
    
    # Store the value
    eval "$var_name='$value'"
}

# Read regular input
read_input() {
    local prompt="$1"
    local var_name="$2"
    local default="$3"
    local value=""
    
    if [[ -n "$default" ]]; then
        echo -n -e "${YELLOW}$prompt${NC} ${CYAN}[$default]${NC}: "
    else
        echo -n -e "${YELLOW}$prompt${NC}: "
    fi
    
    read value
    if [[ -z "$value" && -n "$default" ]]; then
        value="$default"
    fi
    eval "$var_name='$value'"
}

# Read file path and validate
read_file_path() {
    local prompt="$1"
    local var_name="$2"
    local file_path=""
    
    while true; do
        echo -n -e "${YELLOW}$prompt${NC}: "
        read file_path
        
        if [[ -z "$file_path" ]]; then
            echo -e "${RED}Error: File path cannot be empty${NC}"
            continue
        fi
        
        # Expand ~ and resolve relative paths
        file_path=$(eval echo "$file_path")
        
        if [[ ! -f "$file_path" ]]; then
            echo -e "${RED}Error: File does not exist: $file_path${NC}"
            echo -e "${YELLOW}Please enter a valid file path${NC}"
            continue
        fi
        
        eval "$var_name='$file_path'"
        echo -e "${GREEN}✓ File found: $file_path${NC}"
        break
    done
}

# Validate required fields
validate_secrets() {
    local missing=()
    
    [[ -z "$BSC_PRIVATE_KEY" ]] && missing+=("BSC Private Key")
    [[ -z "$BSC_WALLET_ADDRESS" ]] && missing+=("BSC Wallet Address")
    [[ -z "$ALEO_PRIVATE_KEY" ]] && missing+=("Aleo Private Key")
    [[ -z "$ALEO_WALLET_ADDRESS" ]] && missing+=("Aleo Wallet Address")
    [[ -z "$SIGNING_SERVICE_USERNAME" ]] && missing+=("Signing Service Username")
    [[ -z "$SIGNING_SERVICE_PASSWORD" ]] && missing+=("Signing Service Password")
    [[ -z "$CA_CERT_FILE" ]] && missing+=("CA Certificate File")
    [[ -z "$ATTESTOR_CERT_FILE" ]] && missing+=("Attestor Certificate File")
    [[ -z "$ATTESTOR_KEY_FILE" ]] && missing+=("Attestor Key File")
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "${RED}Error: Missing required fields:${NC}"
        for field in "${missing[@]}"; do
            echo -e "  - $field"
        done
        return 1
    fi
    return 0
}

# Read certificate/key content from file
read_file_content() {
    local file_path="$1"
    local content=""
    
    if [[ ! -f "$file_path" ]]; then
        echo -e "${RED}Error: File not found: $file_path${NC}"
        return 1
    fi
    
    content=$(cat "$file_path")
    echo "$content"
}

# Generate JSON file
generate_json() {
    print_section "Generating Secret JSON"
    
    # Read file contents
    echo -e "${CYAN}Reading certificate and key files...${NC}"
    local ca_cert=$(read_file_content "$CA_CERT_FILE")
    local attestor_cert=$(read_file_content "$ATTESTOR_CERT_FILE")
    local attestor_key=$(read_file_content "$ATTESTOR_KEY_FILE")
    
    if [[ -z "$ca_cert" || -z "$attestor_cert" || -z "$attestor_key" ]]; then
        echo -e "${RED}Error: Failed to read certificate/key files${NC}"
        return 1
    fi
    
    # Use Python to generate proper JSON (handles escaping automatically)
    # Pass sensitive values via environment variables to avoid shell escaping issues
    export BSC_PRIVATE_KEY_VAR="$BSC_PRIVATE_KEY"
    export BSC_WALLET_ADDRESS_VAR="$BSC_WALLET_ADDRESS"
    export ALEO_PRIVATE_KEY_VAR="$ALEO_PRIVATE_KEY"
    export ALEO_WALLET_ADDRESS_VAR="$ALEO_WALLET_ADDRESS"
    export SIGNING_SERVICE_USERNAME_VAR="$SIGNING_SERVICE_USERNAME"
    export SIGNING_SERVICE_PASSWORD_VAR="$SIGNING_SERVICE_PASSWORD"
    
    python3 << PYEOF
import json
import sys
import os

# Read file contents
def read_file(file_path):
    try:
        with open(file_path, 'r') as f:
            return f.read()
    except Exception as e:
        print(f"Error reading file {file_path}: {e}", file=sys.stderr)
        sys.exit(1)

ca_cert = read_file('$CA_CERT_FILE')
attestor_cert = read_file('$ATTESTOR_CERT_FILE')
attestor_key = read_file('$ATTESTOR_KEY_FILE')

secret = {
    "mtls": {
        "ca_certificate": ca_cert,
        "attestor_certificate": attestor_cert,
        "attestor_key": attestor_key
    },
    "signing_service": {
        "ethereum_private_key": os.environ.get('BSC_PRIVATE_KEY_VAR', ''),
        "ethereum_wallet_address": os.environ.get('BSC_WALLET_ADDRESS_VAR', ''),
        "aleo_private_key": os.environ.get('ALEO_PRIVATE_KEY_VAR', ''),
        "aleo_wallet_address": os.environ.get('ALEO_WALLET_ADDRESS_VAR', ''),
        "signing_service_username": os.environ.get('SIGNING_SERVICE_USERNAME_VAR', ''),
        "signing_service_password": os.environ.get('SIGNING_SERVICE_PASSWORD_VAR', '')
    }
}

try:
    with open('$OUTPUT_FILE', 'w') as f:
        json.dump(secret, f, indent=2)
    print("✓ Secret JSON generated successfully")
except Exception as e:
    print(f"Error writing JSON file: {e}", file=sys.stderr)
    sys.exit(1)
PYEOF
    
    # Clean up environment variables
    unset BSC_PRIVATE_KEY_VAR
    unset BSC_WALLET_ADDRESS_VAR
    unset ALEO_PRIVATE_KEY_VAR
    unset ALEO_WALLET_ADDRESS_VAR
    unset SIGNING_SERVICE_USERNAME_VAR
    unset SIGNING_SERVICE_PASSWORD_VAR
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}✓ Secret JSON generated: $OUTPUT_FILE${NC}"
        
        # Validate JSON
        if command -v jq &> /dev/null; then
            if jq empty "$OUTPUT_FILE" 2>/dev/null; then
                echo -e "${GREEN}✓ JSON is valid${NC}"
            else
                echo -e "${RED}✗ JSON validation failed${NC}"
                return 1
            fi
        fi
        return 0
    else
        echo -e "${RED}✗ Failed to generate secret JSON${NC}"
        return 1
    fi
}

# Store to AWS Secrets Manager
store_to_aws() {
    print_section "Storing to AWS Secrets Manager"
    
    # Determine secret name based on environment
    local secret_name=""
    case "$ENV" in
        devnet)
            secret_name="dev/verulink/attestor/secrets"
            ;;
        staging)
            secret_name="stg/verulink/attestor/secrets"
            ;;
        mainnet)
            secret_name="mainnet/verulink/attestor/secrets"
            ;;
        *)
            echo -e "${RED}Error: Invalid environment: $ENV${NC}"
            return 1
            ;;
    esac
    
    echo -e "${CYAN}Secret Name: $secret_name${NC}"
    echo -e "${CYAN}Region: $AWS_REGION${NC}"
    
    # Check if AWS CLI is available
    if ! command -v aws &> /dev/null; then
        echo -e "${RED}Error: AWS CLI is not installed${NC}"
        echo -e "${YELLOW}Install it from: https://aws.amazon.com/cli/${NC}"
        return 1
    fi
    
    # Check if secret exists
    echo -e "${CYAN}Checking if secret exists...${NC}"
    if aws secretsmanager describe-secret --secret-id "$secret_name" --region "$AWS_REGION" &>/dev/null; then
        echo -e "${YELLOW}Secret already exists.${NC}"
        read_input "Update existing secret? (yes/no)" UPDATE_SECRET "no"
        
        if [[ "$UPDATE_SECRET" != "yes" ]]; then
            echo -e "${YELLOW}Skipping secret storage${NC}"
            return 0
        fi
        
        # Update existing secret
        echo -e "${CYAN}Updating secret...${NC}"
        if aws secretsmanager update-secret \
            --secret-id "$secret_name" \
            --secret-string "file://$OUTPUT_FILE" \
            --region "$AWS_REGION" &>/dev/null; then
            echo -e "${GREEN}✓ Secret updated successfully${NC}"
            return 0
        else
            echo -e "${RED}✗ Failed to update secret${NC}"
            return 1
        fi
    else
        # Create new secret
        echo -e "${CYAN}Creating new secret...${NC}"
        if aws secretsmanager create-secret \
            --name "$secret_name" \
            --secret-string "file://$OUTPUT_FILE" \
            --region "$AWS_REGION" \
            --description "Verulink Attestor Combined Secrets ($ENV)" &>/dev/null; then
            echo -e "${GREEN}✓ Secret created successfully${NC}"
            return 0
        else
            echo -e "${RED}✗ Failed to create secret${NC}"
            return 1
        fi
    fi
}

# Store to GCP Secret Manager
store_to_gcp() {
    print_section "Storing to GCP Secret Manager"
    
    # Determine secret name based on environment
    local secret_name=""
    case "$ENV" in
        devnet)
            secret_name="dev_verulink_attestor_secrets"
            ;;
        staging)
            secret_name="stg_verulink_attestor_secrets"
            ;;
        mainnet)
            secret_name="mainnet_verulink_attestor_secrets"
            ;;
        *)
            echo -e "${RED}Error: Invalid environment: $ENV${NC}"
            return 1
            ;;
    esac
    
    echo -e "${CYAN}Secret Name: $secret_name${NC}"
    echo -e "${CYAN}Project: $GCP_PROJECT${NC}"
    
    # Check if gcloud CLI is available
    if ! command -v gcloud &> /dev/null; then
        echo -e "${RED}Error: GCP CLI (gcloud) is not installed${NC}"
        echo -e "${YELLOW}Install it from: https://cloud.google.com/sdk/docs/install${NC}"
        return 1
    fi
    
    # Check if secret exists
    echo -e "${CYAN}Checking if secret exists...${NC}"
    if gcloud secrets describe "$secret_name" --project="$GCP_PROJECT" &>/dev/null 2>&1; then
        echo -e "${YELLOW}Secret already exists.${NC}"
        read_input "Add new version? (yes/no)" ADD_VERSION "no"
        
        if [[ "$ADD_VERSION" != "yes" ]]; then
            echo -e "${YELLOW}Skipping secret storage${NC}"
            return 0
        fi
        
        # Add new version
        echo -e "${CYAN}Adding new version...${NC}"
        if gcloud secrets versions add "$secret_name" \
            --project="$GCP_PROJECT" \
            --data-file="$OUTPUT_FILE" &>/dev/null; then
            echo -e "${GREEN}✓ Secret version added successfully${NC}"
            return 0
        else
            echo -e "${RED}✗ Failed to add secret version${NC}"
            return 1
        fi
    else
        # Create new secret
        echo -e "${CYAN}Creating new secret...${NC}"
        if gcloud secrets create "$secret_name" \
            --project="$GCP_PROJECT" \
            --data-file="$OUTPUT_FILE" \
            --replication-policy="automatic" &>/dev/null; then
            echo -e "${GREEN}✓ Secret created successfully${NC}"
            return 0
        else
            echo -e "${RED}✗ Failed to create secret${NC}"
            return 1
        fi
    fi
}

# Main function
main() {
    print_header
    
    # Step 1: Select cloud provider
    print_section "Cloud Provider Selection"
    echo -e "${CYAN}1. AWS Secrets Manager${NC}"
    echo -e "${CYAN}2. GCP Secret Manager${NC}"
    read_input "Select cloud provider (1 or 2)" PROVIDER_CHOICE "1"
    
    case "$PROVIDER_CHOICE" in
        1)
            CLOUD_PROVIDER="aws"
            read_input "AWS Region" AWS_REGION "us-east-1"
            ;;
        2)
            CLOUD_PROVIDER="gcp"
            read_input "GCP Project ID" GCP_PROJECT ""
            if [[ -z "$GCP_PROJECT" ]]; then
                echo -e "${RED}Error: GCP Project ID is required${NC}"
                exit 1
            fi
            ;;
        *)
            echo -e "${RED}Error: Invalid choice${NC}"
            exit 1
            ;;
    esac
    
    # Step 2: Select environment
    print_section "Environment Selection"
    echo -e "${CYAN}1. Devnet${NC}"
    echo -e "${CYAN}2. Staging${NC}"
    echo -e "${CYAN}3. Mainnet${NC}"
    read_input "Select environment (1, 2, or 3)" ENV_CHOICE "1"
    
    case "$ENV_CHOICE" in
        1) ENV="devnet" ;;
        2) ENV="staging" ;;
        3) ENV="mainnet" ;;
        *)
            echo -e "${RED}Error: Invalid choice${NC}"
            exit 1
            ;;
    esac
    
    echo -e "${GREEN}Selected: $ENV environment on $CLOUD_PROVIDER${NC}"
    
    # Step 3: Collect signing service secrets
    print_section "Signing Service Secrets"
    echo -e "${YELLOW}Enter signing service credentials (private keys will be masked)${NC}"
    
    read_masked "BSC Private Key (0x...)" BSC_PRIVATE_KEY
    read_input "BSC Wallet Address (0x...)" BSC_WALLET_ADDRESS ""
    read_masked "Aleo Private Key (APrivateKey1...)" ALEO_PRIVATE_KEY
    read_input "Aleo Wallet Address (aleo1...)" ALEO_WALLET_ADDRESS ""
    read_input "Signing Service Username" SIGNING_SERVICE_USERNAME ""
    read_masked "Signing Service Password" SIGNING_SERVICE_PASSWORD
    
    # Step 4: Collect mTLS certificate files
    print_section "mTLS Certificates and Keys"
    echo -e "${YELLOW}Enter paths to mTLS certificate and key files${NC}"
    
    read_file_path "CA Certificate File Path" CA_CERT_FILE
    read_file_path "Attestor Certificate File Path" ATTESTOR_CERT_FILE
    read_file_path "Attestor Key File Path" ATTESTOR_KEY_FILE
    
    # Step 5: Validate
    print_section "Validation"
    if ! validate_secrets; then
        echo -e "${RED}Validation failed. Please check your inputs.${NC}"
        exit 1
    fi
    echo -e "${GREEN}✓ All required fields provided${NC}"
    
    # Step 6: Generate JSON
    if ! generate_json; then
        echo -e "${RED}Failed to generate secret JSON${NC}"
        exit 1
    fi
    
    # Step 7: Confirm before storing
    print_section "Confirmation"
    echo -e "${YELLOW}Ready to store secret to $CLOUD_PROVIDER${NC}"
    echo -e "${CYAN}Environment: $ENV${NC}"
    echo -e "${CYAN}Output file: $OUTPUT_FILE${NC}"
    read_input "Proceed with storage? (yes/no)" CONFIRM "no"
    
    if [[ "$CONFIRM" != "yes" ]]; then
        echo -e "${YELLOW}Storage cancelled. JSON file saved at: $OUTPUT_FILE${NC}"
        exit 0
    fi
    
    # Step 8: Store to cloud
    if [[ "$CLOUD_PROVIDER" == "aws" ]]; then
        if ! store_to_aws; then
            echo -e "${RED}Failed to store secret to AWS${NC}"
            exit 1
        fi
    else
        if ! store_to_gcp; then
            echo -e "${RED}Failed to store secret to GCP${NC}"
            exit 1
        fi
    fi
    
    # Success
    echo ""
    echo -e "${GREEN}${BOLD}========================================${NC}"
    echo -e "${GREEN}${BOLD}  Secret Stored Successfully!${NC}"
    echo -e "${GREEN}${BOLD}========================================${NC}"
    echo ""
    echo -e "${CYAN}Secret JSON file: $OUTPUT_FILE${NC}"
    echo -e "${YELLOW}Note: Consider removing the JSON file after verification for security${NC}"
}

# Run main function
main "$@"

